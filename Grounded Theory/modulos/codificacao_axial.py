#!/usr/bin/env python3
"""
üîó M√≥dulo de Codifica√ß√£o Axial - Grounded Theory
================================================

Este m√≥dulo implementa a terceira etapa da Grounded Theory: Codifica√ß√£o Axial.
Respons√°vel por relacionar categorias e subcategorias.

üéØ FUNCIONALIDADES:
- Relacionamento entre categorias
- Identifica√ß√£o de condi√ß√µes
- An√°lise de consequ√™ncias
- Estrat√©gias de a√ß√£o
- Paradigma de codifica√ß√£o

üî¨ METODOLOGIA:
- Paradigma de Strauss e Corbin
- Condi√ß√µes causais
- Fen√¥meno central
- Contexto
- Estrat√©gias de interven√ß√£o
- Consequ√™ncias
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, List, Set


class CodificacaoAxial:
    """
    üîó Codifica√ß√£o Axial para Grounded Theory

    Implementa relacionamento entre categorias e subcategorias.
    """

    def __init__(self, logger: logging.Logger):
        """
        Inicializa o codificador axial.

        Args:
            logger: Logger para acompanhamento
        """
        self.logger = logger
        self.paradigma_codificacao = {}
        self.relacionamentos = {}
        self.condicoes_causais = {}
        self.consequencias = {}
        self.estrategias = {}

    def codificar_axial(self, dados_codificacao_aberta: Dict) -> Dict:
        """
        üîó Realiza codifica√ß√£o axial dos dados.

        Args:
            dados_codificacao_aberta: Resultados da codifica√ß√£o aberta

        Returns:
            Dicion√°rio com resultados da codifica√ß√£o axial
        """
        self.logger.info("üîó INICIANDO CODIFICA√á√ÉO AXIAL")

        resultados = {
            "paradigma_codificacao": {},
            "relacionamentos": {},
            "condicoes_causais": {},
            "consequencias": {},
            "estrategias": {},
            "memos_analiticos": [],
            "estatisticas": {},
        }

        # Extrair conceitos e categorias da codifica√ß√£o aberta
        conceitos = dados_codificacao_aberta.get("conceitos_identificados", {})
        categorias = dados_codificacao_aberta.get("categorias_iniciais", {})

        # Aplicar paradigma de codifica√ß√£o
        self._aplicar_paradigma_codificacao(conceitos, categorias)

        # Identificar relacionamentos
        self._identificar_relacionamentos(conceitos, categorias)

        # Analisar condi√ß√µes causais
        self._analisar_condicoes_causais(conceitos)

        # Identificar consequ√™ncias
        self._identificar_consequencias(conceitos)

        # Desenvolver estrat√©gias
        self._desenvolver_estrategias(conceitos, categorias)

        # Criar memos anal√≠ticos
        self._criar_memos_analiticos()

        # Calcular estat√≠sticas
        resultados["estatisticas"] = self._calcular_estatisticas()

        self.logger.info("‚úÖ CODIFICA√á√ÉO AXIAL CONCLU√çDA")
        return resultados

    def _aplicar_paradigma_codificacao(self, conceitos: Dict, categorias: Dict):
        """
        üéØ Aplica o paradigma de codifica√ß√£o de Strauss e Corbin.

        Args:
            conceitos: Conceitos identificados
            categorias: Categorias iniciais
        """
        self.logger.info("üéØ Aplicando paradigma de codifica√ß√£o...")

        paradigma = {
            "condicoes_causais": [],
            "fenomeno_central": [],
            "contexto": [],
            "condicoes_intervenientes": [],
            "estrategias_de_acao": [],
            "consequencias": [],
        }

        # Identificar fen√¥meno central (mais frequente)
        conceitos_frequentes = sorted(
            conceitos.items(), key=lambda x: x[1]["frequencia"], reverse=True
        )

        if conceitos_frequentes:
            fenomeno_central = conceitos_frequentes[0][0]
            paradigma["fenomeno_central"].append(fenomeno_central)
            self.logger.info(f"üéØ Fen√¥meno central identificado: {fenomeno_central}")

        # Classificar outros conceitos
        for conceito, info in conceitos.items():
            if conceito in paradigma["fenomeno_central"]:
                continue

            # Classificar baseado no conte√∫do
            if any(termo in conceito.lower() for termo in ["causa", "origem", "fator"]):
                paradigma["condicoes_causais"].append(conceito)
            elif any(
                termo in conceito.lower()
                for termo in ["contexto", "ambiente", "situa√ß√£o"]
            ):
                paradigma["contexto"].append(conceito)
            elif any(
                termo in conceito.lower()
                for termo in ["interven√ß√£o", "a√ß√£o", "programa"]
            ):
                paradigma["estrategias_de_acao"].append(conceito)
            elif any(
                termo in conceito.lower()
                for termo in ["resultado", "efeito", "impacto"]
            ):
                paradigma["consequencias"].append(conceito)
            else:
                paradigma["condicoes_intervenientes"].append(conceito)

        self.paradigma_codificacao = paradigma

        self.logger.info(f"üéØ Paradigma aplicado: {len(paradigma)} elementos")

    def _identificar_relacionamentos(self, conceitos: Dict, categorias: Dict):
        """
        üîó Identifica relacionamentos entre conceitos.

        Args:
            conceitos: Conceitos identificados
            categorias: Categorias iniciais
        """
        self.logger.info("üîó Identificando relacionamentos...")

        relacionamentos = {}

        # Relacionamentos por categoria
        for categoria, conceitos_categoria in categorias.items():
            if len(conceitos_categoria) > 1:
                relacionamentos[categoria] = {
                    "tipo": "intra_categoria",
                    "conceitos": conceitos_categoria,
                    "forca_relacionamento": "alta",
                }

        # Relacionamentos entre categorias
        categorias_lista = list(categorias.keys())
        for i, cat1 in enumerate(categorias_lista):
            for cat2 in categorias_lista[i + 1 :]:
                chave_relacionamento = f"{cat1}_x_{cat2}"
                relacionamentos[chave_relacionamento] = {
                    "tipo": "inter_categoria",
                    "categoria1": cat1,
                    "categoria2": cat2,
                    "forca_relacionamento": "media",
                }

        self.relacionamentos = relacionamentos

        self.logger.info(f"üîó Relacionamentos identificados: {len(relacionamentos)}")

    def _analisar_condicoes_causais(self, conceitos: Dict):
        """
        üîç Analisa condi√ß√µes causais dos fen√¥menos.

        Args:
            conceitos: Conceitos identificados
        """
        self.logger.info("üîç Analisando condi√ß√µes causais...")

        condicoes = {}

        # Identificar condi√ß√µes causais baseadas em frequ√™ncia
        conceitos_frequentes = [
            conceito
            for conceito, info in conceitos.items()
            if info["frequencia"] > 5  # Mais de 5 ocorr√™ncias
        ]

        for conceito in conceitos_frequentes:
            condicoes[conceito] = {
                "tipo": "condicao_causal",
                "frequencia": conceitos[conceito]["frequencia"],
                "contextos": conceitos[conceito]["contextos"],
                "intensidade": (
                    "alta" if conceitos[conceito]["frequencia"] > 10 else "media"
                ),
            }

        self.condicoes_causais = condicoes

        self.logger.info(f"üîç Condi√ß√µes causais identificadas: {len(condicoes)}")

    def _identificar_consequencias(self, conceitos: Dict):
        """
        üìä Identifica consequ√™ncias dos fen√¥menos.

        Args:
            conceitos: Conceitos identificados
        """
        self.logger.info("üìä Identificando consequ√™ncias...")

        consequencias = {}

        # Identificar consequ√™ncias baseadas em padr√µes
        for conceito, info in conceitos.items():
            if any(
                termo in conceito.lower()
                for termo in ["resultado", "efeito", "impacto", "mudan√ßa"]
            ):
                consequencias[conceito] = {
                    "tipo": "consequencia",
                    "frequencia": info["frequencia"],
                    "contextos": info["contextos"],
                    "natureza": (
                        "positiva" if "melhoria" in conceito.lower() else "neutra"
                    ),
                }

        self.consequencias = consequencias

        self.logger.info(f"üìä Consequ√™ncias identificadas: {len(consequencias)}")

    def _desenvolver_estrategias(self, conceitos: Dict, categorias: Dict):
        """
        üéØ Desenvolve estrat√©gias de a√ß√£o/interven√ß√£o.

        Args:
            conceitos: Conceitos identificados
            categorias: Categorias iniciais
        """
        self.logger.info("üéØ Desenvolvendo estrat√©gias...")

        estrategias = {}

        # Identificar estrat√©gias baseadas em conceitos de a√ß√£o
        for conceito, info in conceitos.items():
            if any(
                termo in conceito.lower()
                for termo in ["a√ß√£o", "interven√ß√£o", "programa", "estrat√©gia"]
            ):
                estrategias[conceito] = {
                    "tipo": "estrategia_acao",
                    "frequencia": info["frequencia"],
                    "contextos": info["contextos"],
                    "viabilidade": "alta" if info["frequencia"] > 3 else "media",
                }

        # Estrat√©gias baseadas em categorias
        if "A√ß√µes" in categorias:
            for acao in categorias["A√ß√µes"]:
                if acao not in estrategias:
                    estrategias[acao] = {
                        "tipo": "estrategia_categoria",
                        "categoria_origem": "A√ß√µes",
                        "viabilidade": "media",
                    }

        self.estrategias = estrategias

        self.logger.info(f"üéØ Estrat√©gias desenvolvidas: {len(estrategias)}")

    def _criar_memos_analiticos(self):
        """
        üìù Cria memos anal√≠ticos sobre a codifica√ß√£o axial.
        """
        self.logger.info("üìù Criando memos anal√≠ticos...")

        memos = []

        # Memo sobre paradigma
        if self.paradigma_codificacao:
            memo_paradigma = {
                "tipo": "paradigma_codificacao",
                "titulo": "Paradigma de Codifica√ß√£o Identificado",
                "conteudo": f"Fen√¥meno central: {self.paradigma_codificacao.get('fenomeno_central', [])}",
                "paradigma": self.paradigma_codificacao,
                "timestamp": datetime.now().isoformat(),
            }
            memos.append(memo_paradigma)

        # Memo sobre relacionamentos
        if self.relacionamentos:
            memo_relacionamentos = {
                "tipo": "relacionamentos",
                "titulo": "Relacionamentos Identificados",
                "conteudo": f"Total de relacionamentos: {len(self.relacionamentos)}",
                "relacionamentos": self.relacionamentos,
                "timestamp": datetime.now().isoformat(),
            }
            memos.append(memo_relacionamentos)

        # Memo sobre estrat√©gias
        if self.estrategias:
            estrategias_viaveis = [
                nome
                for nome, info in self.estrategias.items()
                if info.get("viabilidade") == "alta"
            ]

            memo_estrategias = {
                "tipo": "estrategias_viaveis",
                "titulo": "Estrat√©gias Mais Vi√°veis",
                "conteudo": f"Estrat√©gias de alta viabilidade: {estrategias_viaveis}",
                "estrategias": estrategias_viaveis,
                "timestamp": datetime.now().isoformat(),
            }
            memos.append(memo_estrategias)

        self.memos_analiticos = memos

    def _calcular_estatisticas(self) -> Dict:
        """
        üìä Calcula estat√≠sticas da codifica√ß√£o axial.

        Returns:
            Dicion√°rio com estat√≠sticas
        """
        estatisticas = {
            "total_relacionamentos": len(self.relacionamentos),
            "total_condicoes_causais": len(self.condicoes_causais),
            "total_consequencias": len(self.consequencias),
            "total_estrategias": len(self.estrategias),
            "memos_criados": len(self.memos_analiticos),
        }

        # Estat√≠sticas do paradigma
        if self.paradigma_codificacao:
            for categoria, elementos in self.paradigma_codificacao.items():
                estatisticas[f"paradigma_{categoria}"] = len(elementos)

        return estatisticas

    def salvar_resultados(self, resultados: Dict, nome_arquivo: str = None):
        """
        üíæ Salva resultados da codifica√ß√£o axial.

        Args:
            resultados: Resultados da codifica√ß√£o
            nome_arquivo: Nome do arquivo (opcional)
        """
        if nome_arquivo is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            nome_arquivo = f"codificacao_axial_{timestamp}.json"

        caminho = os.path.join("resultados", nome_arquivo)

        # Criar pasta se n√£o existir
        os.makedirs("resultados", exist_ok=True)

        # Salvar resultados
        with open(caminho, "w", encoding="utf-8") as f:
            json.dump(resultados, f, ensure_ascii=False, indent=2)

        self.logger.info(f"üíæ Resultados salvos em: {caminho}")
