#!/usr/bin/env python3
"""
üîç M√≥dulo de Codifica√ß√£o Aberta - Grounded Theory
=================================================

Este m√≥dulo implementa a segunda etapa da Grounded Theory: Codifica√ß√£o Aberta.
Respons√°vel por identificar conceitos b√°sicos nos dados coletados.

üéØ FUNCIONALIDADES:
- Identifica√ß√£o de conceitos
- Extra√ß√£o de propriedades
- Categoriza√ß√£o inicial
- An√°lise de frequ√™ncia
- Gera√ß√£o de memos

üî¨ METODOLOGIA:
- Codifica√ß√£o linha por linha
- Identifica√ß√£o de conceitos
- Compara√ß√£o constante
- Memos anal√≠ticos
"""

import json
import logging
import os
import re
from collections import Counter
from datetime import datetime
from typing import Dict, List, Set


class CodificacaoAberta:
    """
    üîç Codifica√ß√£o Aberta para Grounded Theory

    Implementa identifica√ß√£o de conceitos b√°sicos nos dados coletados.
    """

    def __init__(self, logger: logging.Logger):
        """
        Inicializa o codificador aberto.

        Args:
            logger: Logger para acompanhamento
        """
        self.logger = logger
        self.conceitos_identificados = {}
        self.categorias_iniciais = {}
        self.memos_analiticos = []

    def codificar_dados(self, dados: List[Dict]) -> Dict:
        """
        üîç Realiza codifica√ß√£o aberta dos dados.

        Args:
            dados: Dados coletados para codifica√ß√£o

        Returns:
            Dicion√°rio com resultados da codifica√ß√£o
        """
        self.logger.info("üîç INICIANDO CODIFICA√á√ÉO ABERTA")
        self.logger.info(f"üìä Dados para codificar: {len(dados)} registros")

        resultados = {
            "conceitos_identificados": {},
            "categorias_iniciais": {},
            "memos_analiticos": [],
            "estatisticas": {},
        }

        # Processar cada registro
        for i, registro in enumerate(dados):
            self.logger.info(f"üîç Codificando registro {i+1}/{len(dados)}")

            # Codificar texto do registro
            conceitos_registro = self._codificar_texto(registro)

            # Adicionar ao dicion√°rio de conceitos
            for conceito, contexto in conceitos_registro.items():
                if conceito not in self.conceitos_identificados:
                    self.conceitos_identificados[conceito] = {
                        "frequencia": 0,
                        "contextos": [],
                        "primeira_ocorrencia": registro.get("id", f"reg_{i}"),
                        "propriedades": set(),
                    }

                self.conceitos_identificados[conceito]["frequencia"] += 1
                self.conceitos_identificados[conceito]["contextos"].append(contexto)

        # Gerar categorias iniciais
        self._gerar_categorias_iniciais()

        # Criar memos anal√≠ticos
        self._criar_memos_analiticos()

        # Calcular estat√≠sticas
        resultados["estatisticas"] = self._calcular_estatisticas()

        self.logger.info("‚úÖ CODIFICA√á√ÉO ABERTA CONCLU√çDA")
        return resultados

    def _codificar_texto(self, registro: Dict) -> Dict[str, str]:
        """
        üîç Codifica o texto de um registro.

        Args:
            registro: Registro individual

        Returns:
            Dicion√°rio de conceitos identificados
        """
        conceitos = {}

        # Extrair texto do registro
        texto_completo = self._extrair_texto_registro(registro)

        # Identificar conceitos usando diferentes estrat√©gias
        conceitos.update(self._identificar_conceitos_por_palavras_chave(texto_completo))
        conceitos.update(self._identificar_conceitos_por_padroes(texto_completo))
        conceitos.update(self._identificar_conceitos_por_frases(texto_completo))

        return conceitos

    def _extrair_texto_registro(self, registro: Dict) -> str:
        """
        üìù Extrai texto completo do registro.

        Args:
            registro: Registro individual

        Returns:
            Texto completo para an√°lise
        """
        campos_texto = ["titulo", "descricao", "palavras_chave", "publico_alvo"]
        texto_completo = ""

        for campo in campos_texto:
            if campo in registro and registro[campo]:
                texto_completo += f" {registro[campo]}"

        return texto_completo.lower().strip()

    def _identificar_conceitos_por_palavras_chave(self, texto: str) -> Dict[str, str]:
        """
        üéØ Identifica conceitos por palavras-chave.

        Args:
            texto: Texto para an√°lise

        Returns:
            Dicion√°rio de conceitos identificados
        """
        conceitos = {}

        # Palavras-chave relacionadas a DEIA
        palavras_chave_deia = [
            "diversidade",
            "equidade",
            "inclus√£o",
            "acessibilidade",
            "sa√∫de mental",
            "popula√ß√£o negra",
            "ind√≠gena",
            "lgbtqi+",
            "pessoa com defici√™ncia",
            "vulnerabilidade",
            "discrimina√ß√£o",
        ]

        for palavra in palavras_chave_deia:
            if palavra in texto:
                conceitos[palavra] = f"Palavra-chave DEIA: {palavra}"

        return conceitos

    def _identificar_conceitos_por_padroes(self, texto: str) -> Dict[str, str]:
        """
        üîç Identifica conceitos por padr√µes de texto.

        Args:
            texto: Texto para an√°lise

        Returns:
            Dicion√°rio de conceitos identificados
        """
        conceitos = {}

        # Padr√µes para identificar conceitos
        padroes = [
            (r"sa√∫de da (\w+)", "Sa√∫de espec√≠fica"),
            (r"popula√ß√£o (\w+)", "Popula√ß√£o espec√≠fica"),
            (r"(\w+) vulner√°vel", "Vulnerabilidade"),
            (r"(\w+) inclusivo", "Inclus√£o"),
            (r"(\w+) acess√≠vel", "Acessibilidade"),
        ]

        for padrao, tipo in padroes:
            matches = re.findall(padrao, texto)
            for match in matches:
                conceito = f"{tipo}: {match}"
                conceitos[conceito] = f"Padr√£o identificado: {padrao}"

        return conceitos

    def _identificar_conceitos_por_frases(self, texto: str) -> Dict[str, str]:
        """
        üìù Identifica conceitos por frases completas.

        Args:
            texto: Texto para an√°lise

        Returns:
            Dicion√°rio de conceitos identificados
        """
        conceitos = {}

        # Frases que indicam conceitos
        frases_conceito = [
            "direitos humanos",
            "cidadania",
            "justi√ßa social",
            "determinantes sociais",
            "promo√ß√£o da sa√∫de",
            "preven√ß√£o",
            "cuidado integral",
        ]

        for frase in frases_conceito:
            if frase in texto:
                conceitos[frase] = f"Frase conceito: {frase}"

        return conceitos

    def _gerar_categorias_iniciais(self):
        """
        üìä Gera categorias iniciais baseadas nos conceitos identificados.
        """
        self.logger.info("üìä Gerando categorias iniciais...")

        # Agrupar conceitos por similaridade
        categorias = {
            "Sa√∫de Espec√≠fica": [],
            "Popula√ß√µes": [],
            "Conceitos DEIA": [],
            "A√ß√µes": [],
            "Contextos": [],
        }

        for conceito, info in self.conceitos_identificados.items():
            if any(
                termo in conceito.lower() for termo in ["sa√∫de", "mental", "f√≠sica"]
            ):
                categorias["Sa√∫de Espec√≠fica"].append(conceito)
            elif any(
                termo in conceito.lower() for termo in ["popula√ß√£o", "pessoa", "grupo"]
            ):
                categorias["Popula√ß√µes"].append(conceito)
            elif any(
                termo in conceito.lower()
                for termo in ["diversidade", "equidade", "inclus√£o"]
            ):
                categorias["Conceitos DEIA"].append(conceito)
            elif any(
                termo in conceito.lower()
                for termo in ["a√ß√£o", "interven√ß√£o", "programa"]
            ):
                categorias["A√ß√µes"].append(conceito)
            else:
                categorias["Contextos"].append(conceito)

        self.categorias_iniciais = categorias

        self.logger.info(f"üìä Categorias geradas: {list(categorias.keys())}")

    def _criar_memos_analiticos(self):
        """
        üìù Cria memos anal√≠ticos sobre a codifica√ß√£o.
        """
        self.logger.info("üìù Criando memos anal√≠ticos...")

        # Memo sobre conceitos mais frequentes
        conceitos_frequentes = sorted(
            self.conceitos_identificados.items(),
            key=lambda x: x[1]["frequencia"],
            reverse=True,
        )[:5]

        memo_frequencia = {
            "tipo": "frequencia_conceitos",
            "titulo": "Conceitos Mais Frequentes",
            "conteudo": f"Os conceitos mais frequentes s√£o: {[c[0] for c in conceitos_frequentes]}",
            "timestamp": datetime.now().isoformat(),
        }

        # Memo sobre categorias
        memo_categorias = {
            "tipo": "categorias_iniciais",
            "titulo": "Categorias Iniciais Identificadas",
            "conteudo": f"Foram identificadas {len(self.categorias_iniciais)} categorias principais",
            "categorias": self.categorias_iniciais,
            "timestamp": datetime.now().isoformat(),
        }

        self.memos_analiticos = [memo_frequencia, memo_categorias]

    def _calcular_estatisticas(self) -> Dict:
        """
        üìä Calcula estat√≠sticas da codifica√ß√£o.

        Returns:
            Dicion√°rio com estat√≠sticas
        """
        total_conceitos = len(self.conceitos_identificados)
        total_categorias = len(self.categorias_iniciais)

        # Conceito mais frequente
        conceito_mais_frequente = (
            max(self.conceitos_identificados.items(), key=lambda x: x[1]["frequencia"])
            if self.conceitos_identificados
            else None
        )

        estatisticas = {
            "total_conceitos": total_conceitos,
            "total_categorias": total_categorias,
            "conceito_mais_frequente": (
                conceito_mais_frequente[0] if conceito_mais_frequente else None
            ),
            "frequencia_maxima": (
                conceito_mais_frequente[1]["frequencia"]
                if conceito_mais_frequente
                else 0
            ),
            "memos_criados": len(self.memos_analiticos),
        }

        return estatisticas

    def salvar_resultados(self, resultados: Dict, nome_arquivo: str = None):
        """
        üíæ Salva resultados da codifica√ß√£o.

        Args:
            resultados: Resultados da codifica√ß√£o
            nome_arquivo: Nome do arquivo (opcional)
        """
        if nome_arquivo is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            nome_arquivo = f"codificacao_aberta_{timestamp}.json"

        caminho = os.path.join("resultados", nome_arquivo)

        # Criar pasta se n√£o existir
        os.makedirs("resultados", exist_ok=True)

        # Salvar resultados
        with open(caminho, "w", encoding="utf-8") as f:
            json.dump(resultados, f, ensure_ascii=False, indent=2)

        self.logger.info(f"üíæ Resultados salvos em: {caminho}")
